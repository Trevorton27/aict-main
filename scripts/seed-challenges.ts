/**
 * Seeds DB from JSON challenge files generated by generate-challenges.ts
 *
 * Run with:
 *   pnpm --filter @aict/web prisma generate
 *   pnpm seed:challenges
 *
 * Requires env:
 *   DATABASE_URL=...
 */
import { PrismaClient } from "@prisma/client";
import fs from "node:fs";
import path from "node:path";

const prisma = new PrismaClient();

async function main() {
  // Handle both root and apps/web contexts
  const cwd = process.cwd();
  let dir = path.join(cwd, "apps", "web", "data", "challenges");
  if (!fs.existsSync(dir)) {
    dir = path.join(cwd, "data", "challenges");
  }
  if (!fs.existsSync(dir)) {
    throw new Error(`Challenge directory not found. Tried: ${path.join(cwd, "apps", "web", "data", "challenges")} and ${path.join(cwd, "data", "challenges")}. Run pnpm gen:challenges first.`);
  }
  const files = fs.readdirSync(dir).filter(f => f.endsWith(".json"));
  if (!files.length) {
    console.warn("No challenge json files found. Did you run pnpm gen:challenges ?");
    return;
  }

  for (const f of files) {
    const raw = fs.readFileSync(path.join(dir, f), "utf8");
    const j = JSON.parse(raw);

    const ch = await prisma.challenge.upsert({
      where: { slug: j.slug },
      update: {
        level: j.level,
        title: j.title,
        objective: j.objective,
        passCriteria: j.passCriteria,
        starter: j.starter,
        tests: j.tests,
        tags: j.tags,
        paramsSchema: j.paramsSchema
      },
      create: {
        level: j.level,
        slug: j.slug,
        title: j.title,
        objective: j.objective,
        passCriteria: j.passCriteria,
        starter: j.starter,
        tests: j.tests,
        tags: j.tags,
        paramsSchema: j.paramsSchema
      }
    });

    if (Array.isArray(j.solutions)) {
      for (const [i, sol] of j.solutions.entries()) {
        await prisma.challengeSolution.create({
          data: {
            challengeId: ch.id,
            label: sol.label || `Solution ${i + 1}`,
            files: sol.files,
            notes: sol.notes ?? null
          }
        });
      }
    }

    if (Array.isArray(j.hints)) {
      for (const h of j.hints) {
        await prisma.challengeHintTemplate.create({
          data: {
            challengeId: ch.id,
            level: h.level,
            text: h.text
          }
        });
      }
    }

    process.stdout.write(`SEEDED ${j.slug}\n`);
  }

  console.log("DONE: seeded", files.length, "challenges.");
}

main()
  .then(async () => { await prisma.$disconnect(); })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });
